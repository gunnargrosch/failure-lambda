[package]
name = "failure-lambda-proxy"
version = "1.0.0"
edition = "2021"

[dependencies]
tokio = { version = "1", features = ["full"] }
hyper = { version = "1", features = ["http1", "server"] }
hyper-util = { version = "0.1", features = ["tokio"] }
http-body-util = "0.1"
bytes = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
regex = "1"
rand = "0.8"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["json"] }
reqwest = { version = "0.12", default-features = false, features = ["json", "rustls-tls"] }

# AWS SDK â€” use ring instead of aws-lc-rs for TLS.
# aws-lc-rs compiles a large C library (BoringSSL) via cmake, adding ~25 min to
# cross-compilation builds. ring is pure Rust/asm and compiles in seconds.
#
# We avoid aws-config's "rustls" feature since it activates "default-https-client"
# which hardcodes aws-lc-rs. Instead we wire up the ring-based HTTP client directly.
aws-config = { version = "1", default-features = false, features = ["rt-tokio", "credentials-process", "sso"] }
aws-sdk-ssm = { version = "1", default-features = false }
aws-smithy-runtime = { version = "1", features = ["client", "rt-tokio", "tls-rustls"] }
aws-smithy-http-client = { version = "1", features = ["rustls-ring"] }
rustls = { version = "0.23", default-features = false, features = ["ring", "logging", "std", "tls12"] }
